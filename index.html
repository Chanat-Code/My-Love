<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏ü‡∏ô‡∏Å‡∏±‡∏ô‡πÑ‡∏´‡∏° üíò</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Thai:wght@400;700&family=Fredoka:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg1:#fff1f5;
      --bg2:#ffe4ea;
      --primary:#ff4d6d;
      --primary-dark:#e63b5b;
      --text:#3d2a2a;
      --shadow: 0 10px 30px rgba(255,77,109,.25);
      --radius: 20px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; min-height:100svh;
      display:grid; place-items:center;
      font-family:'Fredoka', 'Noto Sans Thai', system-ui;
      color:var(--text);
      background: radial-gradient(1200px 1200px at 80% 10%, #ffeef6 0%, transparent 60%),
                  radial-gradient(1000px 800px at 20% 90%, #fff8e6 0%, transparent 60%),
                  linear-gradient(135deg, var(--bg2), var(--bg1));
      overflow:hidden;
    }

    .card{
      position:relative; z-index:2;
      width:min(760px, 94vw);
      background:#fff; border-radius:var(--radius);
      box-shadow: var(--shadow);
      padding: 24px;
      text-align:center;
    }

    h1{
      margin:8px 0 12px; line-height:1.15;
      font-size:clamp(28px, 6vw, 44px);
      color:var(--primary);
    }
    p.tagline{margin:0 0 18px;color:#6b4e4e}

    .mascot{ width:min(240px, 48vw); margin: 8px auto 14px; filter: drop-shadow(0 8px 16px rgba(255,77,109,.25));}

    .button-row{ display:flex; gap:16px; justify-content:center; align-items:center; flex-wrap:wrap; margin-top:14px; position:relative; z-index:3 }

    button{ border:0; border-radius:20px; padding:14px 26px; font-size:18px; cursor:pointer; transition: transform .15s ease, box-shadow .15s ease; box-shadow: 0 8px 18px rgba(0,0,0,.12);}    
    #yesButton{ background:linear-gradient(180deg, var(--primary), var(--primary-dark)); color:#fff; font-weight:700; }
    #yesButton:hover{ transform: translateY(-1px) scale(1.03); box-shadow:0 12px 30px rgba(255,77,109,.35); }
    #yesButton:active{ transform: translateY(0) scale(.98); }

    #noButton{ background:#f3f3f3; color:#333; position:fixed; min-width:78px; text-align:center; z-index:9999; will-change:left, top, transform }

    .burst{ position:fixed; font-size:20px; pointer-events:none; animation:burstAnim 900ms ease forwards; z-index:6 }
    @keyframes burstAnim{ 0%{opacity:1; transform:scale(1) translate(0,0)} 100%{opacity:0; transform:scale(2) translate(var(--x), var(--y))} }

    canvas#confetti{ position:fixed; inset:0; pointer-events:none; z-index:5 }
  </style>
</head>
<body>
  <main class="card">
    <h1>‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏ü‡∏ô‡∏Å‡∏±‡∏ô üòä</h1>
    <p class="tagline">‡∏ñ‡πâ‡∏≤‡∏ï‡∏≠‡∏ö <strong style="color:var(--primary)">‡πÉ‡∏ä‡πà</strong> ‡∏à‡∏∞‡∏°‡∏µ‡∏´‡∏±‡∏ß‡πÉ‡∏à‡∏Å‡∏±‡∏ö‡∏Ñ‡∏≠‡∏ô‡πÄ‡∏ü‡∏ï‡∏ï‡∏¥‡πÄ‡∏ï‡πá‡∏°‡∏ü‡πâ‡∏≤‡πÄ‡∏•‡∏¢ üíñ</p>

    <svg class="mascot" viewBox="0 0 300 260" xmlns="http://www.w3.org/2000/svg">
      <ellipse cx="150" cy="140" rx="100" ry="90" fill="#fffafc" stroke="#ffadc0" stroke-width="3"/>
      <circle cx="115" cy="130" r="8" fill="#3b2f2f"/>
      <circle cx="185" cy="130" r="8" fill="#3b2f2f"/>
      <path d="M135 155 Q150 165 165 155" fill="none" stroke="#3b2f2f" stroke-width="3" stroke-linecap="round"/>
    </svg>

    <div class="button-row">
      <button id="yesButton">‡πÉ‡∏ä‡πà üíò</button>
      <button id="noButton">‡πÑ‡∏°‡πà üòù</button>
    </div>
  </main>

  <canvas id="confetti"></canvas>

  <script>
    const yesButton = document.getElementById('yesButton');
    const noButton  = document.getElementById('noButton');
    const confettiCanvas = document.getElementById('confetti');
    const ctx = confettiCanvas.getContext('2d');

    function resize(){ confettiCanvas.width = innerWidth; confettiCanvas.height = innerHeight; }
    addEventListener('resize', resize); resize();

    // ‡∏õ‡∏∏‡πà‡∏°‡πÑ‡∏°‡πà‡∏´‡∏ô‡∏µ‡∏ó‡∏±‡πà‡∏ß‡∏à‡∏≠‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏≠‡∏≠‡∏Å‡∏ô‡∏≠‡∏Å‡∏Ç‡∏≠‡∏ö
    function moveNoButton(ev){
      const rect = noButton.getBoundingClientRect();
      const pad = 40;
      const maxX = innerWidth - rect.width - pad;
      const maxY = innerHeight - rect.height - pad;
      const newX = pad + Math.random() * maxX;
      const newY = pad + Math.random() * maxY;

      noButton.animate([
        { transform:"scale(1)" },
        { transform:"scale(1.2) rotate(10deg)" },
        { transform:"scale(1) rotate(0)" }
      ], {duration:400,easing:"ease-out"});

      noButton.style.left = newX + "px";
      noButton.style.top  = newY + "px";
    }

    noButton.addEventListener('mouseover', moveNoButton);
    noButton.addEventListener('pointerenter', moveNoButton);
    noButton.addEventListener('touchstart',(e)=>{e.preventDefault(); moveNoButton(e);},{passive:false});

    // confetti ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏î‡πÉ‡∏ä‡πà
    const colors = ['#ff4d6d','#ffd166','#b8f2e6','#cdb4db','#95d5b2'];
    function celebrate(){
      const parts=[]; const N=120;
      for(let i=0;i<N;i++) parts.push({x:Math.random()*confettiCanvas.width,y:-20-Math.random()*innerHeight*0.3,r:4+Math.random()*6,s:2+Math.random()*3,a:Math.random()*Math.PI*2,c:colors[i%colors.length]});
      const start=performance.now();
      function draw(t){
        const elapsed=t-start; ctx.clearRect(0,0,confettiCanvas.width, confettiCanvas.height);
        parts.forEach(p=>{p.y+=p.s;p.x+=Math.sin(p.a+=0.05)*1.5;ctx.save();ctx.translate(p.x,p.y);ctx.rotate(p.a);ctx.fillStyle=p.c;ctx.fillRect(-p.r/2,-p.r/2,p.r,p.r);ctx.restore();});
        if(elapsed<1800) requestAnimationFrame(draw);
      }
      requestAnimationFrame(draw);
    }

    yesButton.addEventListener('click',()=>{
      celebrate();
      alert('‡πÄ‡∏¢‡πâ! ‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏ü‡∏ô‡∏Å‡∏±‡∏ô‡πÅ‡∏•‡πâ‡∏ß‡∏ô‡∏∞ ü•∞');
    });
  </script>
  
  <!-- Patch: stronger evasive logic keeps button on-screen and jumps when pointer is close -->
  <script>
    (function(){
      const noButton = document.getElementById('noButton');
      const yesButton = document.getElementById('yesButton');
      if(!noButton || !yesButton) return;

      const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      function safePad(){ return Math.max(24, Math.min(innerWidth, innerHeight)*0.04); }
      function clamp(n,min,max){ return Math.max(min, Math.min(n,max)); }

      function moveNoButton(ev){
        const rect = noButton.getBoundingClientRect();
        const pad = safePad();
        const maxX = innerWidth  - rect.width  - pad;
        const maxY = innerHeight - rect.height - pad;
        let newX = pad + Math.random()*maxX;
        let newY = pad + Math.random()*maxY;
        const pt = ev?.clientX ? {x:ev.clientX,y:ev.clientY} : (ev?.touches && ev.touches[0] ? {x:ev.touches[0].clientX,y:ev.touches[0].clientY} : null);
        if(pt){
          const awayX = rect.left + rect.width/2 - (pt.x - rect.width*1.4);
          const awayY = rect.top  + rect.height/2 - (pt.y - rect.height*1.4);
          newX = clamp(awayX, pad, maxX);
          newY = clamp(awayY, pad, maxY);
        }
        const dx = newX - rect.left; const dy = newY - rect.top;
        if(!prefersReduced){
          noButton.animate([
            { transform:'translate(0,0)' },
            { transform:`translate(${dx}px,${dy}px) scale(1.15) rotate(8deg)` },
            { transform:`translate(${dx}px,${dy}px) scale(1) rotate(0)` }
          ], { duration: 420, easing:'cubic-bezier(.2,.8,.2,1)', fill:'forwards' });
        }
        noButton.style.position='fixed';
        noButton.style.left = newX + 'px';
        noButton.style.top  = newY + 'px';
      }

      // Rebind listeners (idempotent)
      noButton.onmouseover = moveNoButton;
      noButton.onpointerenter = moveNoButton;
      noButton.onfocus = moveNoButton;
      noButton.ontouchstart = (e)=>{ e.preventDefault(); moveNoButton(e); };

      // Jump away if pointer gets too close (<140px)
      document.addEventListener('pointermove', (e)=>{
        const r = noButton.getBoundingClientRect();
        const cx = r.left + r.width/2, cy = r.top + r.height/2;
        const dist = Math.hypot(e.clientX - cx, e.clientY - cy);
        if(dist < 140) moveNoButton(e);
      }, {passive:true});

      // Keep inside viewport on resize
      window.addEventListener('resize', ()=>{
        const r = noButton.getBoundingClientRect();
        const pad = safePad();
        const maxX = innerWidth  - r.width  - pad;
        const maxY = innerHeight - r.height - pad;
        noButton.style.left = clamp(r.left, pad, maxX) + 'px';
        noButton.style.top  = clamp(r.top , pad, maxY) + 'px';
      }, {passive:true});
    })();
  </script>
  
  <!-- Hotfix: prevent off-screen by removing translate from animation and adding periodic clamp -->
  <script>
    (function(){
      const noButton = document.getElementById('noButton');
      if(!noButton) return;
      const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const safePad = ()=> Math.max(24, Math.min(innerWidth, innerHeight)*0.04);
      const clamp=(n,min,max)=> Math.max(min, Math.min(n,max));

      // Override mover to avoid translate-based animation (which can desync rect)
      window.moveNoButton = function(ev){
        const r = noButton.getBoundingClientRect();
        const pad = safePad();
        const maxX = innerWidth  - r.width  - pad;
        const maxY = innerHeight - r.height - pad;
        let newX = pad + Math.random()*maxX;
        let newY = pad + Math.random()*maxY;
        const pt = ev?.clientX ? {x:ev.clientX,y:ev.clientY} : (ev?.touches && ev.touches[0] ? {x:ev.touches[0].clientX,y:ev.touches[0].clientY} : null);
        if(pt){
          const awayX = r.left + r.width/2 - (pt.x - r.width*1.4);
          const awayY = r.top  + r.height/2 - (pt.y - r.height*1.4);
          newX = clamp(awayX, pad, maxX);
          newY = clamp(awayY, pad, maxY);
        }
        noButton.style.position='fixed';
        noButton.style.left = newX + 'px';
        noButton.style.top  = newY + 'px';
        if(!prefersReduced){
          noButton.animate([
            { transform:'scale(1) rotate(0)' },
            { transform:'scale(1.12) rotate(6deg)' },
            { transform:'scale(1) rotate(0)' }
          ], { duration: 260, easing:'ease-out' });
        }
      };

      // Guard: every 800ms clamp inside viewport
      setInterval(()=>{
        const r = noButton.getBoundingClientRect();
        const pad = safePad();
        const maxX = innerWidth  - r.width  - pad;
        const maxY = innerHeight - r.height - pad;
        const x = clamp(r.left, pad, maxX);
        const y = clamp(r.top , pad, maxY);
        noButton.style.left = x + 'px';
        noButton.style.top  = y + 'px';
      }, 800);
    })();
  </script>
  
  <!-- Final safety net: keep the ‚ÄúNo‚Äù button always on-screen and add quick-restore -->
  <script>
    (function(){
      const noButton = document.getElementById('noButton');
      const yesButton = document.getElementById('yesButton');
      if(!noButton || !yesButton) return;

      const clamp=(n,min,max)=> Math.max(min, Math.min(n,max));
      const pad = ()=> Math.max(24, Math.min(innerWidth, innerHeight)*0.04);

      function ensureInViewport(){
        const r = noButton.getBoundingClientRect();
        const p = pad();
        const maxX = innerWidth  - r.width  - p;
        const maxY = innerHeight - r.height - p;
        const x = clamp(r.left, p, maxX);
        const y = clamp(r.top , p, maxY);
        // snap only if outside
        if (Math.abs(x - r.left) > 1 || Math.abs(y - r.top) > 1){
          noButton.style.position = 'fixed';
          noButton.style.left = x + 'px';
          noButton.style.top  = y + 'px';
        }
      }

      function centerNearYes(){
        const ry = yesButton.getBoundingClientRect();
        const r  = noButton.getBoundingClientRect();
        const p = pad();
        let x = ry.left + ry.width/2 - r.width/2;
        let y = ry.bottom + 16; // just under Yes
        const maxX = innerWidth  - r.width  - p;
        const maxY = innerHeight - r.height - p;
        x = clamp(x, p, maxX); y = clamp(y, p, maxY);
        noButton.style.position='fixed';
        noButton.style.left = x + 'px';
        noButton.style.top  = y + 'px';
      }

      // one-time placement after layout
      window.addEventListener('load', ()=>{ requestAnimationFrame(centerNearYes); });

      // stronger mover: always set fixed+clamp
      window.moveNoButton = function(ev){
        const r = noButton.getBoundingClientRect();
        const p = pad();
        const maxX = innerWidth  - r.width  - p;
        const maxY = innerHeight - r.height - p;
        let nx = p + Math.random()*maxX;
        let ny = p + Math.random()*maxY;
        const pt = ev?.clientX ? {x:ev.clientX,y:ev.clientY} : (ev?.touches && ev.touches[0] ? {x:ev.touches[0].clientX,y:ev.touches[0].clientY} : null);
        if(pt){
          const awayX = r.left + r.width/2 - (pt.x - r.width*1.4);
          const awayY = r.top  + r.height/2 - (pt.y - r.height*1.4);
          nx = clamp(awayX, p, maxX);
          ny = clamp(awayY, p, maxY);
        }
        noButton.style.position='fixed';
        noButton.style.left = nx + 'px';
        noButton.style.top  = ny + 'px';
        ensureInViewport();
      }

      // rebind listeners (in case of earlier overrides)
      noButton.onmouseover = window.moveNoButton;
      noButton.onpointerenter = window.moveNoButton;
      noButton.onfocus = window.moveNoButton;
      noButton.ontouchstart = (e)=>{ e.preventDefault(); window.moveNoButton(e); };

      // proximity trigger
      document.addEventListener('pointermove', (e)=>{
        const r = noButton.getBoundingClientRect();
        const dist = Math.hypot(e.clientX - (r.left+r.width/2), e.clientY - (r.top+r.height/2));
        if(dist < 140) window.moveNoButton(e);
      }, {passive:true});

      // periodic clamp + on resize/visibility
      const clampTimer = setInterval(ensureInViewport, 400);
      window.addEventListener('resize', ensureInViewport, {passive:true});
      document.addEventListener('visibilitychange', ()=>{ if(!document.hidden) ensureInViewport(); });

      // keyboard rescue: press N to recall "No" button near Yes
      window.addEventListener('keydown', (e)=>{ if(e.key.toLowerCase()==='n'){ centerNearYes(); } });
    })();
  </script>
</body>
</html>
